@page "/posts/{PostId:guid}"
@using Meritocious.Common.DTOs.Content
@using Meritocious.Common.DTOs.Merit
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject IUserApiService UserApi
@inject IPostApiService PostApi
@inject IMeritScoringService MeritApi
@inject ISubstackApiService SubstackApi
@inject ICommentApiService CommentApi
@inject IModerationService ModerationService
@inject NotificationService NotificationService
@inject ModalService ModalService

<PageTitle>@(post?.Title ?? "Loading...") - Meritocious</PageTitle>

<div class="container mx-auto px-4 py-6">
    @if (isLoading)
    {
        <Card>
            <div class="flex justify-center p-8">
                <Spin Size="large" Tip="Loading post..." />
            </div>
        </Card>
    }
    else if (post == null)
    {
        <Result Status="404"
                Title="Post Not Found"
                SubTitle="The post you're looking for doesn't exist or has been removed">
            <Button Type="ButtonType.Primary" OnClick="@(() => NavigationManager.NavigateTo("/posts"))">
                Browse Posts
            </Button>
        </Result>
    }
    else
    {
        <Row Gutter="24">
            <Col Span="18">
                <Card>
                    <PostViewComponent Post="@post"
                                  MeritComponents="@meritComponents"
                                  IsOwner="@isOwner"
                                  HasLiked="@hasLiked"
                                  LikesCount="@likesCount"
                                  CommentsCount="@commentsCount"
                                  ReadTime="@readTime"
                                  OnLikeChanged="HandleLikeChanged"
                                  OnDeletePost="HandleDeletePost">
                        <ExtraActions>
                            <Space>
                                <SpaceItem>
                                    <Button Type="default" OnClick="HandleForkPost">
                                        <Template>
                                            <Space>
                                                <SpaceItem><Icon Type="fork" Theme="outline" /></SpaceItem>
                                                <SpaceItem>Fork</SpaceItem>
                                                @if (post.ForkCount > 0)
                                                {
                                                    <SpaceItem><Badge Count="@post.ForkCount" /></SpaceItem>
                                                }
                                            </Space>
                                        </Template>
                                    </Button>
                                </SpaceItem>
                                <SpaceItem>
                                    <Button Type="default" OnClick="HandleRemixPost">
                                        <Template>
                                            <Space>
                                                <SpaceItem><Icon Type="api" Theme="outline" /></SpaceItem>
                                                <SpaceItem>Remix</SpaceItem>
                                                @if (post.RemixCount > 0)
                                                {
                                                    <SpaceItem><Badge Count="@post.RemixCount" /></SpaceItem>
                                                }
                                            </Space>
                                        </Template>
                                    </Button>
                                </SpaceItem>
                                <SpaceItem>
                                    <Dropdown>
                                        <Overlay>
                                            <Menu>
                                                <MenuItem OnClick="HandleExportMarkdown">
                                                    <Icon Type="export" Theme="outline" /> Export as Markdown
                                                </MenuItem>
                                                <MenuItem OnClick="HandleCopyLink">
                                                    <Icon Type="link" Theme="outline" /> Copy Link
                                                </MenuItem>
                                                <MenuItem OnClick="HandleReportPost">
                                                    <Icon Type="flag" Theme="outline" /> Report Post
                                                </MenuItem>
                                            </Menu>
                                        </Overlay>
                                        <ChildContent>
                                            <Button><Icon Type="more" Theme="outline" /></Button>
                                        </ChildContent>
                                    </Dropdown>
                                </SpaceItem>
                            </Space>
                        </ExtraActions>
                    </PostViewComponent>
                </Card>

                <div class="mt-6">
                    <ForkViewerComponent PostId="@PostId" />
                </div>
                
                <div id="comments" class="mt-6">
                    <Card>
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-xl font-bold">Comments (@commentsCount)</h2>
                            <div>
                                <Select DefaultValue="@commentSort" 
                                        Style="width: 180px;"
                                        OnSelectedItemChanged="HandleCommentSortChange">
                                    <SelectOption Value="merit">Sort by Merit</SelectOption>
                                    <SelectOption Value="newest">Sort by Newest</SelectOption>
                                    <SelectOption Value="oldest">Sort by Oldest</SelectOption>
                                </Select>
                            </div>
                        </div>
                        
                        @if (isLoadingComments)
                        {
                            <div class="p-4">
                                <Skeleton Active Avatar Paragraph="new SkeletonParagraph { Rows = 2 }" />
                                <Divider />
                                <Skeleton Active Avatar Paragraph="new SkeletonParagraph { Rows = 2 }" />
                            </div>
                        }
                        else
                        {
                            <CommentsComponent PostId="@PostId"
                                         Comments="@comments"
                                         IsLoading="@isLoadingComments"
                                         IsLoggedIn="@isLoggedIn"
                                         CurrentUserId="@currentUserId"
                                         OnCommentAdded="HandleCommentAdded"
                                         OnCommentDeleted="HandleCommentDeleted"
                                         OnCommentUpdated="HandleCommentUpdated"
                                         OnCommentLiked="HandleCommentLiked"
                                         TotalComments="@commentsCount"
                                         PageSize="@PageSize"
                                         OnLoadMore="@HandleLoadMore" />
                        }
                    </Card>
                </div>
            </Col>
            
            <Col Span="6">
                <Card Title="About the Author" Class="mb-4">
                    <div class="flex items-center space-x-3 mb-3">
                        <Avatar Size="large">@post.AuthorUsername[0]</Avatar>
                        <div>
                            <h3 class="font-medium">
                                <a href="/users/@post.AuthorUsername" class="hover:text-blue-500">
                                    @post.AuthorUsername
                                </a>
                            </h3>
                            <p class="text-gray-500 text-sm">
                                Member since @authorJoinDate.ToString("MMM yyyy")<br/>
                                @(authorBio ?? "No bio provided")
                            </p>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-4 mb-4 text-center">
                        <div>
                            <div class="text-lg font-medium">@authorTotalPosts</div>
                            <div class="text-sm text-gray-500">Posts</div>
                        </div>
                        <div>
                            <div class="text-lg font-medium">@authorAvgMeritScore.ToString("0.00")</div>
                            <div class="text-sm text-gray-500">Avg Merit</div>
                        </div>
                    </div>

                    <Button Type="ButtonType.Default" Block OnClick="HandleFollowAuthor">
                        <Icon Type="@(isFollowingAuthor ? "user-delete" : "user-add")" />
                        @(isFollowingAuthor ? "Unfollow" : "Follow")
                    </Button>
                </Card>
                
                @if (relatedPosts.Any())
                {
                    <Card Title="Similar Posts" Class="mb-4">
                        <List DataSource="@relatedPosts"
                              Size="small"
                              ItemLayout="ListItemLayout.Horizontal">
                            <ListItem>
                                <div>
                                    <div class="text-sm font-medium">
                                        <OpenInTabComponent Title="@context.Title" Url="@($"/posts/{context.Id}")">
                                            <a class="hover:text-blue-500">@context.Title</a>
                                        </OpenInTabComponent>
                                    </div>
                                    <div class="text-xs text-gray-500">
                                        by @context.AuthorUsername • @context.CreatedAt.ToString("MMM d, yyyy")
                                    </div>
                                </div>
                            </ListItem>
                        </List>
                    </Card>
                }
                
                @if (post.SubstackId.HasValue)
                {
                    <Card Title="From Substack" Class="mb-4">
                        @if (isLoadingSubstack)
                        {
                            <Skeleton Active Avatar Paragraph="new SkeletonParagraph { Rows = 2 }" />
                        }
                        else if (substack != null)
                        {
                            <div class="flex items-center space-x-3 mb-3">
                                <Avatar Size="small" Src="@substack.AvatarUrl">
                                    @substack.Name[0]
                                </Avatar>
                                <div>
                                    <h3 class="font-medium">
                                        <OpenInTab Title="@substack.Name" Url="@($"/s/{substack.Slug}")">
                                            <a class="hover:text-blue-500">@substack.Name</a>
                                        </OpenInTab>
                                    </h3>
                                    <p class="text-gray-500 text-xs">@substack.FollowerCount followers</p>
                                </div>
                            </div>
                            
                            <p class="text-sm text-gray-700 line-clamp-3 mb-3">
                                @substack.Description
                            </p>

                        <Button Type="ButtonType.Primary" Block>
                                <Icon Type="plus" /> Follow
                            </Button>
                        }
                    </Card>
                }
            </Col>
        </Row>
    }
</div>

@code {
    [Parameter] public Guid PostId { get; set; }
    [CascadingParameter] private Task<AuthenticationState> AuthState { get; set; }
    [Inject] private ICommentApiService CommentApi { get; set; }
    
    private PostDto post;
    private MeritScoreDto meritComponents;
    private SubstackDto substack;
    private List<PostDto> relatedPosts = new();
    private List<CommentDto> comments = new();
    private CommentListResponse commentResponse;
    
    private bool isLoading = true;
    private bool isLoadingComments = true;
    private bool isLoadingSubstack = true;
    private bool isOwner = false;
    private bool hasLiked = false;
    private bool isLoggedIn = false;
    private int likesCount = 0;
    private int commentsCount = 0;
    private int currentPage = 1;
    private const int PageSize = 20;
    private int readTime = 3;
    private string commentSort = "merit";
    private DateTime authorJoinDate = DateTime.Now.AddYears(-1);
    private string authorBio = null;
    private int authorTotalPosts = 0;
    private decimal authorAvgMeritScore = 0;
    private bool isFollowingAuthor = false;
    private Guid? currentUserId;
    
    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthState;
        isLoggedIn = authState.User.Identity?.IsAuthenticated ?? false;
        if (isLoggedIn)
        {
            currentUserId = Guid.Parse(authState.User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value);
        }

        await LoadPost();
        await LoadComments();
    }
    
    private async Task LoadPost()
    {
        try
        {
            isLoading = true;

            // Load all initial data in parallel
            var postTask = PostApi.GetPostAsync(PostId);
            var meritTask = MeritApi.GetPostMeritScoreAsync(PostId);
            var likesTask = PostApi.GetPostLikesAsync(PostId);
            var commentsTask = CommentApi.GetCommentCountAsync(PostId);

            // Wait for the post to load first since other operations depend on it
            post = await postTask;
            
            if (post == null)
            {
                return;
            }

            // Check if current user is the author
            var authState = await AuthState;
            var userId = authState.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            isOwner = userId == post.AuthorId.ToString();

            // Load author details
            var authorTask = UserApi.GetAuthorDetailsAsync(post.AuthorId);

            // Wait for all remaining tasks
            await Task.WhenAll(meritTask, likesTask, commentsTask, authorTask);

            // Process results
            meritComponents = await meritTask;
            
            var likeInfo = await likesTask;
            hasLiked = likeInfo.HasLiked;
            likesCount = likeInfo.Count;
            
            commentsCount = await commentsTask;

            // Calculate read time
            var words = post.Content.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries).Length;
            readTime = Math.Max(1, (int)Math.Ceiling(words / 225.0));

            // Process author details
            var authorDetails = await authorTask;
            if (authorDetails != null)
            {
                authorBio = authorDetails.Bio;
                authorTotalPosts = authorDetails.TotalPosts;
                authorAvgMeritScore = authorDetails.AverageMeritScore;
                authorJoinDate = authorDetails.JoinDate;
                isFollowingAuthor = authorDetails.IsFollowing;
            }

            // Load related content
            await Task.WhenAll(
                LoadRelatedPosts(),
                LoadSubstack(post.SubstackId)
            );
        }
        catch (ApiException ex)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error loading post",
                Description = ex.Message
            });
            post = null;
        }
        catch (Exception ex)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "An unexpected error occurred while loading the post"
            });
            post = null;
            Console.Error.WriteLine($"Unexpected error loading post: {ex}");
        }
        finally
        {
            isLoading = false;
        }
    }
    
    private async Task LoadRelatedPosts()
    {
        try
        {
            // Load both semantically related and posts from same author
            var semanticTask = PostApi.GetRelatedPostsAsync(PostId, maxResults: 3);
            var authorPostsTask = PostApi.GetAuthorPostsAsync(post.AuthorId, maxResults: 2, excludePostId: PostId);
            
            await Task.WhenAll(semanticTask, authorPostsTask);

            var semanticPosts = await semanticTask;
            var authorPosts = await authorPostsTask;

            // Combine and deduplicate posts
            var allRelated = semanticPosts.ToList();
            foreach (var authorPost in authorPosts)
            {
                if (!allRelated.Any(p => p.Id == authorPost.Id))
                {
                    allRelated.Add(authorPost);
                }
            }

            // Sort by combination of merit score and recency
            relatedPosts = allRelated
                .OrderByDescending(p => (p.MeritScore * 0.7) + 
                    (0.3 * (1 - (DateTime.UtcNow - p.CreatedAt).TotalDays / 30)))
                .Take(5)
                .ToList();
        }
        catch (ApiException ex)
        {
            await NotificationService.Warning(new NotificationConfig
            {
                Message = "Could not load related posts",
                Description = ex.Message
            });
            relatedPosts = new List<PostDto>();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Unexpected error loading related posts: {ex}");
            relatedPosts = new List<PostDto>();
        }
    }
    
    private async Task LoadSubstack(Guid? substackId)
    {
        if (!substackId.HasValue)
        {
            isLoadingSubstack = false;
            return;
        }
        
        try
        {
            isLoadingSubstack = true;
            
            // Load substack details and follow status in parallel
            var substackTask = SubstackApi.GetSubstackDetailsAsync(substackId.Value);
            var followStatusTask = SubstackApi.GetFollowStatusAsync(substackId.Value);
            
            await Task.WhenAll(substackTask, followStatusTask);
            
            substack = await substackTask;
            
            if (substack != null)
            {
                // Load additional substack metrics and user engagement in parallel
                var metricsTask = SubstackApi.GetSubstackMetricsAsync(substackId.Value);
                var engagementTask = isLoggedIn ? 
                    SubstackApi.GetUserEngagementAsync(substackId.Value) : 
                    Task.FromResult<SubstackEngagementDto>(null);
                
                await Task.WhenAll(metricsTask, engagementTask);
                
                var metrics = await metricsTask;
                substack.MetricsSnapshot = metrics;
                
                if (isLoggedIn)
                {
                    var engagement = await engagementTask;
                    substack.UserEngagement = engagement;
                }
            }
        }
        catch (ApiException ex) when (ex.StatusCode == 404)
        {
            // Substack might have been deleted
            await NotificationService.Warning(new NotificationConfig
            {
                Message = "Substack not found",
                Description = "The substack associated with this post no longer exists"
            });
            substack = null;
        }
        catch (ApiException ex)
        {
            await NotificationService.Warning(new NotificationConfig
            {
                Message = "Could not load substack details",
                Description = ex.Message
            });
            substack = null;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Unexpected error loading substack: {ex}");
            substack = null;
        }
        finally
        {
            isLoadingSubstack = false;
        }
    }
    
    private async Task HandleLikeChanged(bool newLikedState)
    {
        if (!isLoggedIn)
        {
            var returnUrl = Uri.EscapeDataString(NavigationManager.Uri);
            NavigationManager.NavigateTo($"/login?returnUrl={returnUrl}");
            return;
        }

        try
        {
            var oldState = hasLiked;
            var oldCount = likesCount;

            // Optimistically update UI
            hasLiked = newLikedState;
            likesCount += newLikedState ? 1 : -1;

            try
            {
                var likeInfo = await PostApi.UpdateLikeStatusAsync(PostId, newLikedState);
                
                // Update with actual server state
                hasLiked = likeInfo.HasLiked;
                likesCount = likeInfo.Count;

                // Show transient success message
                if (hasLiked)
                {
                    await NotificationService.Success(new NotificationConfig 
                    { 
                        Message = "Post liked",
                        Description = "This post will appear in your liked posts collection",
                        Duration = 3 // seconds
                    });
                }
            }
            catch
            {
                // Revert optimistic update on failure
                hasLiked = oldState;
                likesCount = oldCount;
                throw;
            }
        }
        catch (ApiException ex) when (ex.StatusCode == 429) // Rate limit
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Please slow down",
                Description = "You're liking posts too quickly. Please wait a moment and try again."
            });
        }
        catch (ApiException ex) when (ex.StatusCode == 404)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Post not found",
                Description = "This post may have been deleted"
            });

            // Refresh the page to show post deleted state
            NavigationManager.NavigateTo(NavigationManager.Uri, forceLoad: true);
        }
        catch (ApiException ex) when (ex.StatusCode == 403)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Action not allowed",
                Description = "You don't have permission to like this post"
            });
        }
        catch (ApiException ex)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error updating like status",
                Description = ex.Message
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Unexpected error updating like status: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "An unexpected error occurred while updating like status"
            });
        }
    }
    
    private async Task HandleDeletePost()
    {
        if (!isLoggedIn || !isOwner)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Permission denied",
                Description = "You don't have permission to delete this post"
            });
            return;
        }

        try
        {
            // Show confirmation dialog with deletion implications
            var confirmOptions = new ConfirmOptions
            {
                Title = "Delete Post",
                Icon = IconType.Outline.ExclamationCircle,
                Content = @$"Are you sure you want to delete ""{post.Title}""?

This will:
• Permanently remove the post and its content
• Remove it from all collections and search results
• Keep fork relationships for derived posts
• Notify users who have interacted with this post",
                OkText = "Delete Post",
                OkType = "danger",
                CancelText = "Cancel",
                Centered = true,
                Mask = true,
                MaskClosable = false,
                OnOk = async (e) =>
                {
                    try
                    {
                        // Show loading state
                        await e.UpdateLoadingAsync(true);
                        
                        // Perform deletion
                        await PostApi.DeletePostAsync(PostId);

                        // Show success message
                        await NotificationService.Success(new NotificationConfig
                        {
                            Message = "Post deleted",
                            Description = "The post has been permanently removed"
                        });

                        // Navigate to posts listing or user profile
                        var authState = await AuthState;
                        var userId = authState.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                        NavigationManager.NavigateTo($"/users/{userId}/posts");
                    }
                    catch (ApiException ex) when (ex.StatusCode == 409)
                    {
                        await NotificationService.Error(new NotificationConfig
                        {
                            Message = "Cannot delete post",
                            Description = "This post cannot be deleted because it has active forks or remixes"
                        });
                    }
                    catch (ApiException ex) when (ex.StatusCode == 404)
                    {
                        await NotificationService.Warning(new NotificationConfig
                        {
                            Message = "Post already deleted",
                            Description = "This post has already been deleted by another user"
                        });
                        NavigationManager.NavigateTo("/posts");
                    }
                    catch (ApiException ex)
                    {
                        await NotificationService.Error(new NotificationConfig
                        {
                            Message = "Error deleting post",
                            Description = ex.Message
                        });
                    }
                    catch (Exception ex)
                    {
                        Console.Error.WriteLine($"Unexpected error deleting post: {ex}");
                        await NotificationService.Error(new NotificationConfig
                        {
                            Message = "Error",
                            Description = "An unexpected error occurred while deleting the post"
                        });
                    }
                }
            };

            // Show the confirmation dialog
            await ModalService.ConfirmAsync(confirmOptions);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error showing delete confirmation: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not show delete confirmation dialog"
            });
        }
    }
    
    private async Task HandleCommentSortChange(string value)
    {
        try
        {
            commentSort = value;
            await LoadComments();
        }
        catch (Exception ex)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not change comment sort order"
            });
            Console.Error.WriteLine($"Error changing comment sort: {ex}");
        }
    }

    private async Task LoadComments(bool append = false)
    {
        try
        {
            if (!append)
            {
                isLoadingComments = true;
                currentPage = 1;
                comments.Clear();
            }

            var response = await CommentApi.GetPostCommentsAsync(
                PostId, 
                currentPage, 
                PageSize, 
                commentSort
            );

            commentResponse = response;
            commentsCount = response.TotalCount;

            if (append)
                comments.AddRange(response.Comments);
            else
                comments = response.Comments;
        }
        catch (ApiException ex)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error loading comments",
                Description = ex.Message
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Unexpected error loading comments: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not load comments"
            });
        }
        finally
        {
            isLoadingComments = false;
        }
    }

    private async Task HandleCommentAdded(CommentDto comment)
    {
        if (!isLoggedIn)
        {
            NavigationManager.NavigateTo($"/login?returnUrl={Uri.EscapeDataString(NavigationManager.Uri)}");
            return;
        }

        try
        {
            // Run content moderation check first
            var moderationResult = await ModerationService.CheckContentAsync(comment.Content);
            if (!moderationResult.IsApproved)
            {
                await NotificationService.Error(new NotificationConfig
                {
                    Message = "Comment rejected",
                    Description = moderationResult.RejectionReason
                });
                return;
            }

            // Add the comment
            var newComment = await CommentApi.AddCommentAsync(comment);
            
            // Update UI
            comments.Insert(0, newComment);
            commentsCount++;
            StateHasChanged();

            // Show success message
            await NotificationService.Success(new NotificationConfig
            {
                Message = "Comment added",
                Description = null,
                Duration = 3
            });
        }
        catch (ApiException ex) when (ex.StatusCode == 429)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Please slow down",
                Description = "You're commenting too quickly. Please wait a moment."
            });
        }
        catch (ApiException ex)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error adding comment",
                Description = ex.Message
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Unexpected error adding comment: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not add comment"
            });
        }
    }

    private async Task HandleCommentDeleted(Guid commentId)
    {
        if (!isLoggedIn)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Permission denied",
                Description = "You must be logged in to delete comments"
            });
            return;
        }

        try
        {
            var confirmOptions = new ConfirmOptions
            {
                Title = "Delete Comment",
                Icon = IconType.Outline.ExclamationCircle,
                Content = "Are you sure you want to delete this comment? This action cannot be undone.",
                OkText = "Delete",
                OkType = "danger",
                CancelText = "Cancel",
                OnOk = async (e) =>
                {
                    try
                    {
                        await e.UpdateLoadingAsync(true);
                        await CommentApi.DeleteCommentAsync(commentId);
                        
                        comments.RemoveAll(c => c.Id == commentId);
                        commentsCount--;
                        StateHasChanged();

                        await NotificationService.Success(new NotificationConfig
                        {
                            Message = "Comment deleted",
                            Duration = 3
                        });
                    }
                    catch (ApiException ex)
                    {
                        await NotificationService.Error(new NotificationConfig
                        {
                            Message = "Error deleting comment",
                            Description = ex.Message
                        });
                    }
                }
            };

            await ModalService.ConfirmAsync(confirmOptions);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error showing delete confirmation: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not delete comment"
            });
        }
    }

    private async Task HandleCommentUpdated(CommentDto comment)
    {
        if (!isLoggedIn)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Permission denied",
                Description = "You must be logged in to edit comments"
            });
            return;
        }

        try
        {
            // Run content moderation check first
            var moderationResult = await ModerationService.CheckContentAsync(comment.Content);
            if (!moderationResult.IsApproved)
            {
                await NotificationService.Error(new NotificationConfig
                {
                    Message = "Edit rejected",
                    Description = moderationResult.RejectionReason
                });
                return;
            }

            // Update the comment
            var updatedComment = await CommentApi.UpdateCommentAsync(comment);
            
            // Update UI
            var index = comments.FindIndex(c => c.Id == comment.Id);
            if (index != -1)
            {
                comments[index] = updatedComment;
                StateHasChanged();
            }

            await NotificationService.Success(new NotificationConfig
            {
                Message = "Comment updated",
                Duration = 3
            });
        }
        catch (ApiException ex) when (ex.StatusCode == 409)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Edit conflict",
                Description = "This comment was modified by someone else. Please refresh and try again."
            });
        }
        catch (ApiException ex)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error updating comment",
                Description = ex.Message
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Unexpected error updating comment: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not update comment"
            });
        }
    }

    private async Task HandleCommentLiked(Guid commentId)
    {
        if (!isLoggedIn)
        {
            NavigationManager.NavigateTo($"/login?returnUrl={Uri.EscapeDataString(NavigationManager.Uri)}");
            return;
        }

        try
        {
            var comment = comments.FirstOrDefault(c => c.Id == commentId);
            if (comment == null) return;

            var oldState = comment.HasLiked;
            var oldCount = comment.LikesCount;

            // Optimistic update
            comment.HasLiked = !comment.HasLiked;
            comment.LikesCount += comment.HasLiked ? 1 : -1;
            StateHasChanged();

            try
            {
                var result = await CommentApi.UpdateLikeStatusAsync(commentId, comment.HasLiked);
                
                // Update with actual server state
                comment.HasLiked = result.HasLiked;
                comment.LikesCount = result.LikesCount;
                StateHasChanged();
            }
            catch
            {
                // Revert optimistic update on failure
                comment.HasLiked = oldState;
                comment.LikesCount = oldCount;
                StateHasChanged();
                throw;
            }
        }
        catch (ApiException ex) when (ex.StatusCode == 429)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Please slow down",
                Description = "You're liking comments too quickly. Please wait a moment."
            });
        }
        catch (ApiException ex)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error updating like status",
                Description = ex.Message
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Unexpected error liking comment: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not update comment like status"
            });
        }
    }

    private async Task HandleFollowAuthor()
    {
        if (!isLoggedIn)
        {
            NavigationManager.NavigateTo($"/login?returnUrl={Uri.EscapeDataString(NavigationManager.Uri)}");
            return;
        }

        if (post.AuthorId == currentUserId)
        {
            await NotificationService.Info(new NotificationConfig
            {
                Message = "Cannot follow yourself",
                Description = "You cannot follow your own profile"
            });
            return;
        }

        try
        {
            var oldState = isFollowingAuthor;

            // Optimistic update
            isFollowingAuthor = !isFollowingAuthor;
            StateHasChanged();

            try
            {
                if (isFollowingAuthor)
                {
                    await UserApi.FollowUserAsync(post.AuthorId);
                    
                    await NotificationService.Success(new NotificationConfig
                    {
                        Message = $"Following {post.AuthorUsername}",
                        Description = "You will see their posts in your feed",
                        Duration = 3
                    });
                }
                else
                {
                    await UserApi.UnfollowUserAsync(post.AuthorId);
                    
                    await NotificationService.Success(new NotificationConfig
                    {
                        Message = $"Unfollowed {post.AuthorUsername}",
                        Duration = 3
                    });
                }

                // Update author metrics
                var authorDetails = await UserApi.GetAuthorDetailsAsync(post.AuthorId);
                if (authorDetails != null)
                {
                    authorBio = authorDetails.Bio;
                    authorTotalPosts = authorDetails.TotalPosts;
                    authorAvgMeritScore = authorDetails.AverageMeritScore;
                    authorJoinDate = authorDetails.JoinDate;
                    isFollowingAuthor = authorDetails.IsFollowing;
                }
            }
            catch
            {
                // Revert optimistic update on failure
                isFollowingAuthor = oldState;
                StateHasChanged();
                throw;
            }
        }
        catch (ApiException ex) when (ex.StatusCode == 429)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Please slow down",
                Description = "You're following users too quickly. Please wait a moment."
            });
        }
        catch (ApiException ex) when (ex.StatusCode == 403)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Action not allowed",
                Description = "You cannot follow this user at this time. They may have blocked you or been suspended."
            });
        }
        catch (ApiException ex)
        {
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error updating follow status",
                Description = ex.Message
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Unexpected error following author: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not update follow status"
            });
        }
    }

    private async Task HandleLoadMore((int page, int pageSize) args)
    {
        currentPage = args.page;
        await LoadComments(append: true);
    }
    
    private class LikeInfo
    {
        public bool HasLiked { get; set; }
        public int Count { get; set; }
    }

    private async Task HandleForkPost()
    {
        if (!isLoggedIn)
        {
            NavigationManager.NavigateTo($"/login?returnUrl={Uri.EscapeDataString(NavigationManager.Uri)}");
            return;
        }

        try
        {
            // Show fork dialog with options
            var forkOptions = new ConfirmOptions
            {
                Title = "Fork Post",
                Icon = IconType.Outline.Fork,
                Width = 700,
                Content = @$"You are about to fork ""{post.Title}"".

A fork creates a new independent copy of this post that you can modify. The relationship between the posts will be preserved in the fork graph.

How would you like to proceed?",
                OkText = "Create Fork",
                CancelText = "Cancel",
                OnOk = async (e) =>
                {
                    try
                    {
                        await e.UpdateLoadingAsync(true);

                        // Create the fork
                        var fork = await PostApi.CreateForkAsync(post.Id);

                        // Navigate to fork editor
                        var tabData = TabItemData.Create(
                            $"Fork: {post.Title}",
                            $"/posts/{fork.Id}/edit",
                            new Dictionary<string, object>
                            {
                                { "postId", fork.Id },
                                { "parentId", post.Id },
                                { "relationship", "fork" }
                            }
                        );

                        await TabService.OpenInNewTabAsync(
                            $"/posts/{fork.Id}/edit",
                            tabData
                        );

                        await NotificationService.Success(new NotificationConfig
                        {
                            Message = "Fork created",
                            Description = "You can now edit your fork"
                        });
                    }
                    catch (ApiException ex) when (ex.StatusCode == 403)
                    {
                        await NotificationService.Error(new NotificationConfig
                        {
                            Message = "Cannot fork post",
                            Description = "You don't have permission to fork this post"
                        });
                    }
                    catch (ApiException ex)
                    {
                        await NotificationService.Error(new NotificationConfig
                        {
                            Message = "Error creating fork",
                            Description = ex.Message
                        });
                    }
                }
            };

            await ModalService.ConfirmAsync(forkOptions);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error handling fork: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not create fork"
            });
        }
    }

    private async Task HandleRemixPost()
    {
        if (!isLoggedIn)
        {
            NavigationManager.NavigateTo($"/login?returnUrl={Uri.EscapeDataString(NavigationManager.Uri)}");
            return;
        }

        try 
        {
            // Get existing remix sources if any
            var existingSources = new List<PostDto>();
            if (LocalStorage.ContainKey("remixSources"))
            {
                var sourceIds = await LocalStorage.GetItemAsync<List<Guid>>("remixSources");
                existingSources = await PostApi.GetPostsByIdsAsync(sourceIds);
            }

            // Show remix dialog
            var remixOptions = new ModalOptions
            {
                Title = "Create Remix",
                Width = 800,
                Footer = null,
                MaskClosable = false,
                Content = builder =>
                {
                    builder.OpenComponent<RemixBuilderComponent>(0);
                    builder.AddAttribute(1, "InitialSources", existingSources);
                    builder.AddAttribute(2, "NewSource", post);
                    builder.AddAttribute(3, "OnCancel", EventCallback.Factory.Create(this, async () =>
                    {
                        await ModalService.DestroyAllAsync();
                    }));
                    builder.AddAttribute(4, "OnCreate", EventCallback.Factory.Create<RemixCreateModel>(this, async (model) =>
                    {
                        try
                        {
                            // Create the remix
                            var remix = await PostApi.CreateRemixAsync(new CreateRemixRequest
                            {
                                Title = model.Title,
                                Description = model.Description,
                                Sources = model.Sources.Select(s => s.Id).ToList(),
                                QuoteSelections = model.QuoteSelections
                            });

                            // Save sources for future remixes
                            await LocalStorage.SetItemAsync("remixSources", 
                                model.Sources.Select(s => s.Id).ToList());

                            // Navigate to remix editor
                            var tabData = TabItemData.Create(
                                $"Remix: {model.Title}",
                                $"/posts/{remix.Id}/edit",
                                new Dictionary<string, object>
                                {
                                    { "postId", remix.Id },
                                    { "parentIds", model.Sources.Select(s => s.Id).ToList() },
                                    { "relationship", "remix" }
                                }
                            );

                            await TabService.OpenInNewTabAsync(
                                $"/posts/{remix.Id}/edit",
                                tabData
                            );

                            await ModalService.DestroyAllAsync();

                            await NotificationService.Success(new NotificationConfig
                            {
                                Message = "Remix created",
                                Description = "You can now edit your remix"
                            });
                        }
                        catch (ApiException ex)
                        {
                            await NotificationService.Error(new NotificationConfig
                            {
                                Message = "Error creating remix",
                                Description = ex.Message
                            });
                        }
                    }));
                    builder.CloseComponent();
                }
            };

            await ModalService.CreateAsync(remixOptions);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error handling remix: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not create remix"
            });
        }
    }

    private async Task HandleExportMarkdown()
    {
        try
        {
            var content = await PostApi.ExportMarkdownAsync(post.Id);
            await JSRuntime.InvokeVoidAsync("downloadFile", 
                $"{post.Title.ToLower().Replace(" ", "-")}.md",
                "text/markdown",
                content);

            await NotificationService.Success(new NotificationConfig
            {
                Message = "Export complete",
                Description = "Markdown file downloaded",
                Duration = 3
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error exporting markdown: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Export failed",
                Description = "Could not export post"
            });
        }
    }

    private async Task HandleCopyLink()
    {
        try
        {
            var url = NavigationManager.ToAbsoluteUri($"/posts/{post.Id}").ToString();
            await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", url);

            await NotificationService.Success(new NotificationConfig
            {
                Message = "Link copied",
                Duration = 3
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error copying link: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not copy link"
            });
        }
    }

    private async Task HandleReportPost()
    {
        if (!isLoggedIn)
        {
            NavigationManager.NavigateTo($"/login?returnUrl={Uri.EscapeDataString(NavigationManager.Uri)}");
            return;
        }

        try
        {
            var reportOptions = new ModalOptions
            {
                Title = "Report Post",
                Width = 600,
                Footer = null,
                Content = builder =>
                {
                    builder.OpenComponent<ReportContentComponent>(0);
                    builder.AddAttribute(1, "ContentId", post.Id);
                    builder.AddAttribute(2, "ContentType", "post");
                    builder.AddAttribute(3, "OnCancel", EventCallback.Factory.Create(this, async () =>
                    {
                        await ModalService.DestroyAllAsync();
                    }));
                    builder.AddAttribute(4, "OnSubmit", EventCallback.Factory.Create<ReportContentModel>(this, async (model) =>
                    {
                        try
                        {
                            await ModerationService.ReportContentAsync(new ReportContentRequest
                            {
                                ContentId = post.Id,
                                ContentType = "post",
                                ReasonType = model.ReasonType,
                                ReasonDetails = model.Details
                            });

                            await ModalService.DestroyAllAsync();

                            await NotificationService.Success(new NotificationConfig
                            {
                                Message = "Report submitted",
                                Description = "Thank you for helping keep the community safe",
                                Duration = 3
                            });
                        }
                        catch (ApiException ex)
                        {
                            await NotificationService.Error(new NotificationConfig
                            {
                                Message = "Error submitting report",
                                Description = ex.Message
                            });
                        }
                    }));
                    builder.CloseComponent();
                }
            };

            await ModalService.CreateAsync(reportOptions);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error showing report dialog: {ex}");
            await NotificationService.Error(new NotificationConfig
            {
                Message = "Error",
                Description = "Could not show report dialog"
            });
        }
    }

    private class AuthorDetails
    {
        public string Bio { get; set; }
        public int TotalPosts { get; set; }
        public decimal AverageMeritScore { get; set; }
        public DateTime JoinDate { get; set; }
        public bool IsFollowing { get; set; }
    }
}